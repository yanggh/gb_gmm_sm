/* Generated by nbec  on Sat May 27 04:19:05 2017
 */
#include <stdlib.h>
#include "nbp_rt.h"
#include "nbe_pu_gb_public.h"

#include "nbe_pu_gb_public.h"
#include "nbp_gb_head.h"

#define NPCTX      struct gb_head_ctx*
#define YYCTYPE     uint8_t
#define YYCURSOR    (cursor)
#define YYLIMIT     (limit)
#define YYMARKER    (marker)
#define CTXMARKER  (ctxmarker)
#define YYSTART     (input)
#define YYDEBUG(s,c) { if (s == -1) { printf("%c", c); } }
#define NBPCALL(n)       goto n
#define NBPRET(n)       goto n
#define SET_NOMATCH()  (match = -1)
#define SET_MATCH(n)  (match = (n))
#define NOMATCH()      (match == -1)
#define IS_MATCH()      (match != -1)
#define MATCH      (match)
#define MYVAR(v)   (pctx->v)
#define SAVEPOS(p) (MYVAR(p) = YYCURSOR - YYSTART)
#define RESTOREPOS(p) (YYCURSOR = YYSTART + MYVAR(p), MYVAR(p) = -1)
struct gb_head_ctx {
    scan_state __ss;
    nbe_pu_gb_public *gb_public;
    int frame_head;
    int frame_len;
    int skip_len;
    int $ipt[1];
    int app;
    int module;
    int __g;
    int gtype;
    decompressor_gzip_t*__gdecom;
};
static int do_scan(void *pState, uint8_t *input, uint32_t len, int flag, uint32_t *plen, void *userdata);
static int do_scan(void *pState, uint8_t *input, uint32_t len, int flag, uint32_t *plen, void *userdata) {
    register uint16_t yych = 0x100;
    yych = yych + 0;
    uint8_t *cursor = input;
    uint8_t *limit = input + len;
    uint8_t *marker = input;
    uint8_t *ctxmarker = input;
    int match = -1;
    int eof = flag;
    eof = eof + 0;
    int bit_remain = 8;
    int last_left = 0;
    NPCTX pctx = (NPCTX) pState;
    if (pctx->__ss.c) NBERESUME();
    if (pctx->$ipt[0] > 0) pctx->$ipt[1] = -1;
    goto GB_HEAD_ca;
FRAME_HEAD_ca_1:
{{ {typedef struct  bit_part {
uint16_t data : 16;
} bit_part;
if(YYLIMIT < (YYCURSOR + 2)) {YYFILL(s1, (2 - (YYLIMIT-YYCURSOR)));} { bit_part p;
int r = nbe_read_uint16(YYCURSOR, 2, 0, 1, 0, (uint16_t *)&p);
    if (r == 0) {
       nbe_gb_public_set_frame_head(MYVAR(gb_public), p.data);
    }
}}
if(YYCURSOR + 2 > YYLIMIT) {YYFILL(s2, 2 - (YYLIMIT - YYCURSOR));} {YYCURSOR += 2 ;}};SET_MATCH(0);}NBPRET(FRAME_HEAD_ca_1_ret);
FRAME_LEN_ca_2:
{{ {typedef struct  bit_part {
uint16_t data : 16;
} bit_part;
if(YYLIMIT < (YYCURSOR + 2)) {YYFILL(s3, (2 - (YYLIMIT-YYCURSOR)));} { bit_part p;
int r = nbe_read_uint16(YYCURSOR, 2, 0, 1, 0, (uint16_t *)&p);
    if (r == 0) {
        MYVAR(frame_len) = p.data;
    }
   }}
{
nbe_gb_public_set_frame_len(MYVAR(gb_public), (MYVAR(frame_len)));
}
if(YYCURSOR + 2 > YYLIMIT) {YYFILL(s4, 2 - (YYLIMIT - YYCURSOR));} {YYCURSOR += 2 ;}};SET_MATCH(0);}NBPRET(FRAME_LEN_ca_2_ret);
COLLECT_TIME_ca_3:
{{ if(YYCURSOR + 8 > YYLIMIT) {YYFILL(s5, 8 - (YYLIMIT - YYCURSOR));} {YYCURSOR += 8 ;}};SET_MATCH(0);}NBPRET(COLLECT_TIME_ca_3_ret);
BOARD_NUM_ca_4:
{{ {typedef struct  bit_part {
uint8_t data : 8;
} bit_part;
if(YYLIMIT < (YYCURSOR + 1)) {YYFILL(s6, (1 - (YYLIMIT-YYCURSOR)));} { bit_part p;
int r = nbe_read_uint8(YYCURSOR, 1, 0, 1, 0, (uint8_t *)&p);
    if (r == 0) {
       nbe_gb_public_set_board_num(MYVAR(gb_public), p.data);
    }
}}
if(YYCURSOR + 1 > YYLIMIT) {YYFILL(s7, 1 - (YYLIMIT - YYCURSOR));} {YYCURSOR += 1 ;}};SET_MATCH(0);}NBPRET(BOARD_NUM_ca_4_ret);
PORT_NUM_ca_5:
{{ {typedef struct  bit_part {
uint8_t data : 8;
} bit_part;
if(YYLIMIT < (YYCURSOR + 1)) {YYFILL(s8, (1 - (YYLIMIT-YYCURSOR)));} { bit_part p;
int r = nbe_read_uint8(YYCURSOR, 1, 0, 1, 0, (uint8_t *)&p);
    if (r == 0) {
       nbe_gb_public_set_port_num(MYVAR(gb_public), p.data);
    }
}}
if(YYCURSOR + 1 > YYLIMIT) {YYFILL(s9, 1 - (YYLIMIT - YYCURSOR));} {YYCURSOR += 1 ;}};SET_MATCH(0);}NBPRET(PORT_NUM_ca_5_ret);
TIME_SLOT_ca_6:
{{ {typedef struct  bit_part {
uint8_t data : 8;
} bit_part;
if(YYLIMIT < (YYCURSOR + 1)) {YYFILL(s10, (1 - (YYLIMIT-YYCURSOR)));} { bit_part p;
int r = nbe_read_uint8(YYCURSOR, 1, 0, 1, 0, (uint8_t *)&p);
    if (r == 0) {
       nbe_gb_public_set_time_slot(MYVAR(gb_public), p.data);
    }
}}
if(YYCURSOR + 1 > YYLIMIT) {YYFILL(s11, 1 - (YYLIMIT - YYCURSOR));} {YYCURSOR += 1 ;}};SET_MATCH(0);}NBPRET(TIME_SLOT_ca_6_ret);
DATA_NO_ca_7:
{{ {typedef struct  bit_part {
uint32_t data : 32;
} bit_part;
if(YYLIMIT < (YYCURSOR + 4)) {YYFILL(s12, (4 - (YYLIMIT-YYCURSOR)));} { bit_part p;
int r = nbe_read_uint32(YYCURSOR, 4, 0, 1, 0, (uint32_t *)&p);
    if (r == 0) {
       nbe_gb_public_set_data_num(MYVAR(gb_public), p.data);
    }
}}
if(YYCURSOR + 4 > YYLIMIT) {YYFILL(s13, 4 - (YYLIMIT - YYCURSOR));} {YYCURSOR += 4 ;}};SET_MATCH(0);}NBPRET(DATA_NO_ca_7_ret);
DATA_CONTENT_ca_8:
{{ MYVAR(gb_public)->data_pos = YYCURSOR-YYSTART;
MYVAR(skip_len) =MYVAR(frame_len)- 21 ;{
nbe_gb_public_set_data_len(MYVAR(gb_public), (MYVAR(skip_len)));
}
if(YYCURSOR + MYVAR(skip_len) > YYLIMIT) {YYFILL(s14, MYVAR(skip_len) - (YYLIMIT - YYCURSOR));} {YYCURSOR += MYVAR(skip_len) ;}};SET_MATCH(0);}NBPRET(DATA_CONTENT_ca_8_ret);
CHECKSUM_ca_9:
{{ if(YYCURSOR + 2 > YYLIMIT) {YYFILL(s15, 2 - (YYLIMIT - YYCURSOR));} {YYCURSOR += 2 ;}};SET_MATCH(0);}NBPRET(CHECKSUM_ca_9_ret);
GB_HEAD_ca:
{{ };SET_MATCH(0);}   SET_NOMATCH();
   NBPCALL(FRAME_HEAD_ca_1);
FRAME_HEAD_ca_1_ret:
   if(NOMATCH()) return match;
   SET_NOMATCH();
   NBPCALL(FRAME_LEN_ca_2);
FRAME_LEN_ca_2_ret:
   if(NOMATCH()) return match;
   SET_NOMATCH();
   NBPCALL(COLLECT_TIME_ca_3);
COLLECT_TIME_ca_3_ret:
   if(NOMATCH()) return match;
   SET_NOMATCH();
   NBPCALL(BOARD_NUM_ca_4);
BOARD_NUM_ca_4_ret:
   if(NOMATCH()) return match;
   SET_NOMATCH();
   NBPCALL(PORT_NUM_ca_5);
PORT_NUM_ca_5_ret:
   if(NOMATCH()) return match;
   SET_NOMATCH();
   NBPCALL(TIME_SLOT_ca_6);
TIME_SLOT_ca_6_ret:
   if(NOMATCH()) return match;
   SET_NOMATCH();
   NBPCALL(DATA_NO_ca_7);
DATA_NO_ca_7_ret:
   if(NOMATCH()) return match;
   SET_NOMATCH();
   NBPCALL(DATA_CONTENT_ca_8);
DATA_CONTENT_ca_8_ret:
   if(NOMATCH()) return match;
   SET_NOMATCH();
   NBPCALL(CHECKSUM_ca_9);
CHECKSUM_ca_9_ret:
   if(NOMATCH()) return match;
return match;
}
#ifdef __cpluscplus
extern "C" {
#endif
void *gb_head_state_new(nbp_pd_extract_context *extctx){
    NPCTX pState = (NPCTX) malloc(sizeof(struct gb_head_ctx));
    if (!pState) {
      printf("out of memory");
      return NULL;
    }
    memset(pState, 0, sizeof(*pState));
    if(extctx) {
        pState->app = extctx->app;
        pState->module = extctx->module;
    }
    pState->gb_public = nbe_gb_public_new();
    pState->$ipt[0] = 0;
    if(pState->$ipt[0] > 0) pState->$ipt[1] = -1;
    return pState;//TODO:NULL LOG
}
void gb_head_state_free(void *state) {
    NPCTX pState = (NPCTX) state;
    if (pState->__ss.bf != NULL) free(pState->__ss.bf);
    nbe_gb_public_free(pState->gb_public);
    if (pState->__gdecom) pState->__gdecom->super.destroy(pState->__gdecom);
    free(pState);
}
nbe_pu_gb_public *gb_head_get_userdata(void *pState) {
    return ((NPCTX)pState)->gb_public;
}
int gb_head_get_param(void *pState, int index, void *param, int len) {
    NPCTX pctx = (NPCTX) pState;
    switch (index) {
        default:
            return -1;
    }
    return 0;
}
int gb_head_set_param(void *pState, int index, void *param, int len) {
    NPCTX pctx = (NPCTX) pState;
    switch (index) {
        default:
            return -1;
    }
    return 0;
}
int gb_head_parse(void *pState, uint8_t *input, uint32_t input_len, int flag, void *ctx) {
    NPCTX pctx = (NPCTX) pState;
    uint32_t plen = 0;
    int match = -1;
    if (pctx->__g == 0) {
       match = do_scan(pState, input, input_len, flag, &plen, ctx);
       if (pctx->__g == 1) {
         goto decom;
       }
       return match;
    }
decom:
    if (pctx->__gdecom == NULL) {
       pctx->__gdecom =(decompressor_gzip_t*) gzip_decompressor_create(pctx->gtype);
       pctx->__gdecom->super.callback = do_scan;
    }
    pctx->__gdecom->ueof = flag;
    pctx->__gdecom->ustate = pctx;
    return pctx->__gdecom->super.decompress(pctx->__gdecom, input + plen, (uint32_t)(input_len - plen));
}
#ifdef __cpluscplus
}
#endif
